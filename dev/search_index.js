var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API Reference","title":"API","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"External API\nInternal API\nBase extensions","category":"page"},{"location":"api/#External-API","page":"API Reference","title":"External API","text":"","category":"section"},{"location":"api/#SMGReader.AuxField","page":"API Reference","title":"SMGReader.AuxField","text":"AuxField\n\nDescribes the location and type of an auxiliary field in a BAM record.\n\nFields:\n\ntag::NTuple{2, UInt8}: Two-character tag identifying the field.\ntypechar::UInt8: Type character for the field (e.g., 'A', 'Z', 'B', etc.).\nelemtypechar::UInt8: Element type character for array fields ('B').\nstart::Int: Start index (1-based) of the field value in the record's byte array.\nstop::Int: Stop index (1-based) of the field value in the record's byte array.\n\n\n\n\n\n","category":"type"},{"location":"api/#SMGReader.AuxFieldIter","page":"API Reference","title":"SMGReader.AuxFieldIter","text":"AuxFieldIter(record::BamRecord)\n\nAn iterator over the auxiliary fields of a BAM record.  Yields AuxField objects describing the location and type of each aux field in the record.\n\n\n\n\n\n","category":"type"},{"location":"api/#SMGReader.AuxMapMod","page":"API Reference","title":"SMGReader.AuxMapMod","text":"AuxMapMod()\n\nConstruct an map of the aux data for HP, MM, ML fields. For standard use in chromatin stencilling (non-fire) and direct RNA.\n\n\n\n\n\n","category":"type"},{"location":"api/#SMGReader.AuxMapModFiberTools","page":"API Reference","title":"SMGReader.AuxMapModFiberTools","text":"AuxMapModFiberTools()\n\nConstruct and map of the aux data for a Fiber tools BAM/CRAM mapping fields (that missing the aq fire field)\n\nhp: Haplotype\nmm: Run length encoded mod bases\nml: Mod Probability\nns: Nucleosome positions\nnl: nucleosome length\nas: msp positions\nal: msp lengths\n\n\n\n\n\n","category":"type"},{"location":"api/#SMGReader.AuxMapModFire","page":"API Reference","title":"SMGReader.AuxMapModFire","text":"AuxMapModFire()\n\nConstruct and map of the aux data for a FIRE BAM/CRAM mapping fields\n\nhp: Haplotype\nmm: Run length encoded mod bases\nml: Mod Probability\nns: Nucleosome positions\nnl: nucleosome length\nas: msp positions\nal: msp lengths\naq: msp quality score\n\n\n\n\n\n","category":"type"},{"location":"api/#SMGReader.DirectRNA","page":"API Reference","title":"SMGReader.DirectRNA","text":"DirectRNA(auxmap::AuxMap)\n\nConstruct preallocated HTS read data building a read to genome map for DirectRNA setting an BAM auxillary data map AuxMap. e.g.\n\nFor generic tracking of modifications DirectRNA(AuxMapMod())\n\n\n\n\n\n","category":"type"},{"location":"api/#SMGReader.DirectRNAAlignBlocks","page":"API Reference","title":"SMGReader.DirectRNAAlignBlocks","text":"DirectRNAAlignBlocks(auxmap::AuxMap)\n\nConstruct preallocated HTS read data building both a read to genome map and an align blocks to genome map for spliced alignments.  e.g.\n\nFor generic tracking of modifications DirectRNAAlignBlocks(AuxMapMod())\n\n\n\n\n\n","category":"type"},{"location":"api/#SMGReader.ModIterator","page":"API Reference","title":"SMGReader.ModIterator","text":"struct ModIterator\n\nAn iterator over all modification calls (as ModificationInfo) in a BAM/CRAM record, as described by the MM and ML auxiliary fields.\n\nFields\n\nrecord::BamRecord: The BAM/CRAM record.\nmmaux::AuxField: The MM auxiliary field (modification code and run length encoding of).\nmlaux::AuxField: The ML auxiliary field (modification probabilities).\n\n\n\n\n\n","category":"type"},{"location":"api/#SMGReader.ModIterator-Tuple{BamRecord, SMGReader.HTSReadData}","page":"API Reference","title":"SMGReader.ModIterator","text":"ModIterator(record::BamRecord, rdata::HTSReadData)\n\nConstruct a ModIterator for a given BAM/CRAM record, using the mm and ml fields in the auxmap\n\n\n\n\n\n","category":"method"},{"location":"api/#SMGReader.ModIterator-Tuple{BamRecord}","page":"API Reference","title":"SMGReader.ModIterator","text":"ModIterator(record::BamRecord)\n\nConstruct a ModIterator for a given BAM/CRAM record, automatically extracting the MM and ML fields.\n\n\n\n\n\n","category":"method"},{"location":"api/#SMGReader.Modification","page":"API Reference","title":"SMGReader.Modification","text":"Modification\n\nEnumerates supported DNA/RNA modification types, such as 6mA, 5mC, 5hmC, inosine, pseudouridine, and others. Used to identify the type of modification parsed from MM/ML fields.\n\nCurrently supported mod codes:\n\nEnum value Modification BAM code\nmod_6mA N6-methyladenine a\nmod_5mC 5-methylcytosine m\nmod_5hmC 5-hydroxymethylcytosine h\nmod_inosine Inosine 17596\nmod_pseU Pseudouridine 17802\nmod_4mC N4-methylcytosine 21839\n\n\n\n\n\n","category":"type"},{"location":"api/#SMGReader.ModificationInfo","page":"API Reference","title":"SMGReader.ModificationInfo","text":"ModificationInfo\n\nHolds information about a single modification call parsed from a BAM/CRAM record.\n\nFields\n\nmod::Modification: The modification type.\nstrand::Bool: true for forward (+), false for reverse (-) strand.\npos::Int: 1-based position in the read sequence. \nprob::UInt8: Modification probability (from ML field).\n\n\n\n\n\n","category":"type"},{"location":"api/#SMGReader.StencillingData","page":"API Reference","title":"SMGReader.StencillingData","text":"StencillingData(auxmap::AuxMap)\n\nConstruct preallocated HTS read data building a read to genome map for chromatin stencilling setting an BAM auxillary data map AuxMap. e.g.\n\nFor generic tracking of modifications StencillingData(AuxMapMod())\nFor tracking FIRE fields StencillingData(AuxMapModFire())\n\n\n\n\n\n","category":"type"},{"location":"api/#SMGReader.VectorBuffer","page":"API Reference","title":"SMGReader.VectorBuffer","text":"mutable struct VectorBuffer{T} <: AbstractVector{T}\n\nA resizable buffer that wraps a Vector{T} and tracks a logical length (len). Efficient for repeated resizing and reuse, e.g., when processing records in a loop.\n\nRecommendation is to allocate a large enough vector buffer to work with, e.g.\nfollowing constants are set in processedread.jl\n\nconst MOD_6MA_BUFFER_LENGTH = 70_000\nconst MOD_5MC_BUFFER_LENGTH = 70_000\nconst READ_BUFFER_LENGTH = 200_000\nconst ALIGN_BLOCK_LENGTH = 5_000\n\n\n\n\n\n","category":"type"},{"location":"api/#SMGReader.VectorBuffer-Union{Tuple{Int64}, Tuple{T}, Tuple{Int64, Any}} where T","page":"API Reference","title":"SMGReader.VectorBuffer","text":"VectorBuffer{T}(backcapacity::Int, initcapacity=0)\n\nConstruct a VectorBuffer with backing storage of size backcapacity and logical length initcapacity.\n\n\n\n\n\n","category":"method"},{"location":"api/#SMGReader.autodetectaux-Tuple{String}","page":"API Reference","title":"SMGReader.autodetectaux","text":"autodetectaux(file::String)\n\nAutodetect auxillary map of file. Only checks first record and assumes all records have the same aux fields. \n\n\n\n\n\n","category":"method"},{"location":"api/#SMGReader.cigarstring-Tuple{Any}","page":"API Reference","title":"SMGReader.cigarstring","text":"cigarstring(record)\n\nReturn CIGAR string of record.\n\n\n\n\n\n","category":"method"},{"location":"api/#SMGReader.cigarvec","page":"API Reference","title":"SMGReader.cigarvec","text":"cigarvec(record)\n\nGet CIGAR description of alignment of record returned as lengths (Vector{Int}) and codes (Vector{Char}).\n\nTo build alignment map use readtogenome instead of working with cigar directly\n\n\n\n\n\n","category":"function"},{"location":"api/#SMGReader.eachintersection-Tuple{HTSFileReader, AbstractString, UnitRange{Int64}}","page":"API Reference","title":"SMGReader.eachintersection","text":"eachintersection(reader::HTSFileReader, chrom::AbstractString, loc::UnitRange{Int})\n\nConstruct an iterator of reader over chrom and loc.\n\n\n\n\n\n","category":"method"},{"location":"api/#SMGReader.eachrecord-Tuple{HTSFileReader}","page":"API Reference","title":"SMGReader.eachrecord","text":"eachrecord(reader::HTSFileReader)\n\nConstruct an iterator of reader in record order. Multiple successive calls will continue iterating from current point in reader, resetting iterator requires closing and opening file.\n\n\n\n\n\n","category":"method"},{"location":"api/#SMGReader.firegenome-Tuple{BamRecord, StencillingData{AuxMapModFire}}","page":"API Reference","title":"SMGReader.firegenome","text":"firegenome(record::BamRecord, recorddata::StencillingData{AuxMapModFire}\n\nConstruct a function for mapping fire nucleosomes and MSP coordiates from read coordinates to genome filtering out entries that do not map\n\nUsage:     firegenomecoords = firegenome(record, recorddata)\n\nfor (pos, len, qual) in firegenomcoords(firemsps(record, recorddata))\n    ### do something with genome coordinates\nend\n\n\n\n\n\n","category":"method"},{"location":"api/#SMGReader.firegenomecoords-NTuple{4, Any}","page":"API Reference","title":"SMGReader.firegenomecoords","text":"firegenomecoords(pos::Int, len::Int, record::BamRecord, recorddata::HTSReadData; onebased=true)\n\nSpecial version of genomecoords for fiber-tools and fire elements that are encoded 0-based.\n\npos is zero-based position on the read\none-based = true  returns one based inclusive coords\none-based = false returns zero based exclusive coords\n\n\n\n\n\n","category":"method"},{"location":"api/#SMGReader.firemsps-Tuple{BamRecord, StencillingData{AuxMapModFire}}","page":"API Reference","title":"SMGReader.firemsps","text":"firemsps(r::BamRecord, recorddata::StencillingData{AuxMapModFire})\n\nConstruct iterator of fire msp positions, lengths, and quality scores in read coordinates Usage:\n\nfor (pos, len, qual) in firemsps(record, recorddata)\n    ### do something \nend\n\n\n\n\n\n","category":"method"},{"location":"api/#SMGReader.firenucs-Tuple{BamRecord, StencillingData{AuxMapModFire}}","page":"API Reference","title":"SMGReader.firenucs","text":"firenucs(r::BamRecord, recorddata::StencillingData{AuxMapModFire})\n\nConstruct iterator of fire nucleosome positions, lengths in read coordinates Usage:\n\nfor (pos, len) in firenucs(record, recorddata)\n    ### do something \nend\n\n\n\n\n\n","category":"method"},{"location":"api/#SMGReader.flag-Tuple{BamRecord}","page":"API Reference","title":"SMGReader.flag","text":"flag(record::BamRecord)\n\nGet flag of record\n\n\n\n\n\n","category":"method"},{"location":"api/#SMGReader.genomecoords-Tuple{Any, Any, BamRecord, SMGReader.HTSReadData}","page":"API Reference","title":"SMGReader.genomecoords","text":"genomecoords(pos::Int, len::Int, record::BamRecord, recorddata::HTSReadData; onebased=true)\n\nMap read coordinates to genome coordates that uses alignmap in recorddata,\n\npos is one-based to match the alignment map\none-based = true  returns one based inclusive coords\none-based = false returns zero based exclusive coords\n\n\n\n\n\n","category":"method"},{"location":"api/#SMGReader.genomecoords-Tuple{Int64, BamRecord, SMGReader.HTSReadData}","page":"API Reference","title":"SMGReader.genomecoords","text":"genomecoords(pos::Int, record::BamRecord, recorddata::HTSReadData; onebased=true)\n\nMap read coordinates to genome coordates that uses alignmap in recorddata, onebased=true for 1-based coordinates\n\n\n\n\n\n","category":"method"},{"location":"api/#SMGReader.haplotype","page":"API Reference","title":"SMGReader.haplotype","text":"haplotype(record::BamRecord, recorddata::HTSReadData)\n\nReturn haplotype of record and nothing if haplotype missing\n\n\n\n\n\n","category":"function"},{"location":"api/#SMGReader.hashaplotype-Tuple{BamRecord, SMGReader.HTSReadData}","page":"API Reference","title":"SMGReader.hashaplotype","text":"hashaplotype(record::BamRecord, recorddata::HTSReadData)\n\nReturn true if record has haplotype field\n\n\n\n\n\n","category":"method"},{"location":"api/#SMGReader.indexfile-Tuple{Any}","page":"API Reference","title":"SMGReader.indexfile","text":"indexfile(file)\n\nReturn a .bai or .crai file as appropriate for bam and cram files\n\n\n\n\n\n","category":"method"},{"location":"api/#SMGReader.ispositive-Tuple{BamRecord}","page":"API Reference","title":"SMGReader.ispositive","text":"ispositive(record::BamRecord)\n\nDetermine if record is aligned to the positive strand\n\n\n\n\n\n","category":"method"},{"location":"api/#SMGReader.leftposition-Tuple{BamRecord}","page":"API Reference","title":"SMGReader.leftposition","text":"leftposition(record::BamRecord)\n\nReturn the position of the record in 0-based coords\n\n\n\n\n\n","category":"method"},{"location":"api/#SMGReader.mappingquality-Tuple{BamRecord}","page":"API Reference","title":"SMGReader.mappingquality","text":"mappingquality(record::BamRecord)\n\nReturn mapping quality of record\n\n\n\n\n\n","category":"method"},{"location":"api/#SMGReader.matepos-Tuple{BamRecord}","page":"API Reference","title":"SMGReader.matepos","text":"mateposition(record::BamRecord)\n\nreturn the mate position in 0-based coords\n\n\n\n\n\n","category":"method"},{"location":"api/#SMGReader.materefname-Tuple{HTSFileReader, BamRecord}","page":"API Reference","title":"SMGReader.materefname","text":"materefname(reader::HTSFileReader, record::BamRecord)\n\nReturn the reference name of the mate of record read by reader. reader is necessary to load the ref name from the header of the bam/cram file.\n\n\n\n\n\n","category":"method"},{"location":"api/#SMGReader.nrecords-Tuple{HTSFileReader}","page":"API Reference","title":"SMGReader.nrecords","text":"nrecords(reader::HTSFileReader)\n\nReturn the total number of reads in the file, using the index.\n\n\n\n\n\n","category":"method"},{"location":"api/#SMGReader.processread!-Tuple{BamRecord, SMGReader.HTSReadData}","page":"API Reference","title":"SMGReader.processread!","text":"processread!(record::BamRecord, recorddata::HTSReadData)\n\nProcess read mapping auxillary fields and building read to genome map using preallocated recorddata.\n\n\n\n\n\n","category":"method"},{"location":"api/#SMGReader.qname-Tuple{BamRecord}","page":"API Reference","title":"SMGReader.qname","text":"qname(record::BamRecord)\n\nReturn query name of record. The read name.\n\n\n\n\n\n","category":"method"},{"location":"api/#SMGReader.qual-Tuple{BamRecord}","page":"API Reference","title":"SMGReader.qual","text":"qual(record::BamRecord)\n\nGet quality scores as byte array\n\n\n\n\n\n","category":"method"},{"location":"api/#SMGReader.querylength-Tuple{BamRecord}","page":"API Reference","title":"SMGReader.querylength","text":"querylength(record::BamRecord)\n\nReturn the query length of the record\n\n\n\n\n\n","category":"method"},{"location":"api/#SMGReader.refname-Tuple{HTSFileReader, BamRecord}","page":"API Reference","title":"SMGReader.refname","text":"refname(reader::HTSFileReader, record::BamRecord)\n\nReturn the reference name of record read by reader. reader is necessary to load the ref name from the header of the bam/cram file.\n\n\n\n\n\n","category":"method"},{"location":"api/#SMGReader.rightposition-Tuple{SMGReader.HTSReadData}","page":"API Reference","title":"SMGReader.rightposition","text":"rightposition(recorddata::HTSReadData)\n\nGet the right position of alignment on genome.\n\n\n\n\n\n","category":"method"},{"location":"api/#SMGReader.seq-Tuple{Any}","page":"API Reference","title":"SMGReader.seq","text":"seq(record)\n\nReturn seq string of record.\n\n\n\n\n\n","category":"method"},{"location":"api/#SMGReader.setlength!","page":"API Reference","title":"SMGReader.setlength!","text":"setlength!(buff::VectorBuffer, newlen, backfactor=1.2)\n\nResize the logical length of the buffer to newlen. If the backing storage is too small, resize it by a factor of backfactor or double the current length, whichever is larger. Returns the buffer.\n\n\n\n\n\n","category":"function"},{"location":"api/#SMGReader.templatelength-Tuple{BamRecord}","page":"API Reference","title":"SMGReader.templatelength","text":"templatelength(record::BamRecord)\n\nreturn the template length of the record\n\n\n\n\n\n","category":"method"},{"location":"api/#SMGReader.validflag-Tuple{BamRecord}","page":"API Reference","title":"SMGReader.validflag","text":"validfrag(record::BamRecord)\n\nReturn true if flag is 0 or 16.\n\n\n\n\n\n","category":"method"},{"location":"api/#Internal-API","page":"API Reference","title":"Internal API","text":"","category":"section"},{"location":"api/#SMGReader.ModIteratorState","page":"API Reference","title":"SMGReader.ModIteratorState","text":"ModIteratorState\n\nMutable internal state of ModIterator\n\nFields\n\nnewrecord::Bool: Bool marking whether next iteration will return a new modification with different modcode\nbase::UInt8: Current base associated with modcode\nstrand::Bool: String of modfication\nmod::Modification: Current modification\nmm_pos::Int: Position in the MM string\nml_pos::Int: Position in the ML vector\nseq_pos::Int: Position in the bam sequence\n\n\n\n\n\n","category":"type"},{"location":"api/#SMGReader.alignmentblocks!-Tuple{BamRecord, VectorBuffer{SMGReader.AlignBlock}}","page":"API Reference","title":"SMGReader.alignmentblocks!","text":"alignmentblocks!(record::BamRecord, alignblocks::VectorBuffer{AlignBlock})\n\nIn place update of alignment blocks for a record\n\n\n\n\n\n","category":"method"},{"location":"api/#SMGReader.auxmap!-Tuple{BamRecord, AuxMapMod}","page":"API Reference","title":"SMGReader.auxmap!","text":"auxmap!(record::BamRecord, auxmap<:Auxmap)\n\nConstruct map of auxillary data from record identifying fields specified by auxmap.\n\n\n\n\n\n","category":"method"},{"location":"api/#SMGReader.checkbounds-Tuple{VectorBuffer, Any}","page":"API Reference","title":"SMGReader.checkbounds","text":"checkbounds(buff::VectorBuffer, i)\n\nCheck if index i is within the logical bounds of the buffer. Throws BoundsError if out of bounds.\n\n\n\n\n\n","category":"method"},{"location":"api/#SMGReader.findnextbase-Tuple{BamRecord, UInt8, Int64, Int64}","page":"API Reference","title":"SMGReader.findnextbase","text":"findnextbase(record::BamRecord, base::UInt8, start::Int, skip::Int)\n\nFind the next occurence of base = (0x01, 0x02, 0x04, 0x08)for(A, C, G, T)within the bam bit packed sequence, starting from positionstartskipping overskip` occurences of the base.\n\nThis function is designed to locate the next base for which modification data is available for parsing the MM run length encoded aux field.\n\n\n\n\n\n","category":"method"},{"location":"api/#SMGReader.findprevbase-Tuple{BamRecord, UInt8, Int64, Int64}","page":"API Reference","title":"SMGReader.findprevbase","text":"findprevbase(record::BamRecord, base::UInt8, start::Int, skip::Int)\n\nFind the prev occurence of base = (0x01, 0x02, 0x04, 0x08)for(A, C, G, T)within the bam bit packed sequence, starting from positionstartskipping overskip` occurences of the base.\n\nThis function is designed to locate the prev base for which modification data is available for parsing the MM run length encoded aux field.\n\nThis is the reverse version of findnextbase for use in reverse strand aligned reads.\n\n\n\n\n\n","category":"method"},{"location":"api/#SMGReader.firemsplen-Tuple{BamRecord, StencillingData{AuxMapModFire}}","page":"API Reference","title":"SMGReader.firemsplen","text":"firemsplen(r::BamRecord, recorddata::StencillingData{AuxMapModFire})\n\nReturn fiber tools annotated MSP lengths on read coordinates.\n\n\n\n\n\n","category":"method"},{"location":"api/#SMGReader.firemsppos-Tuple{BamRecord, StencillingData{AuxMapModFire}}","page":"API Reference","title":"SMGReader.firemsppos","text":"firemsppos(r::BamRecord, recorddata::StencillingData{AuxMapModFire})\n\nReturn fiber tools annotated MSP positions on read coordinates. 0-based coordinates.\n\n\n\n\n\n","category":"method"},{"location":"api/#SMGReader.firemspqual-Tuple{BamRecord, StencillingData{AuxMapModFire}}","page":"API Reference","title":"SMGReader.firemspqual","text":"firemspqual(r::BamRecord, recorddata::StencillingData{AuxMapModFire})\n\nReturn fiber tools annotated MSP quality scores on read coordinates.\n\n\n\n\n\n","category":"method"},{"location":"api/#SMGReader.firenuclen-Tuple{BamRecord, StencillingData{AuxMapModFire}}","page":"API Reference","title":"SMGReader.firenuclen","text":"firenuclen(r::BamRecord, recorddata::StencillingData{AuxMapModFire})\n\nReturn fiber tools annotated nucleosome lengths on read coordinates.\n\n\n\n\n\n","category":"method"},{"location":"api/#SMGReader.firenucpos-Tuple{BamRecord, StencillingData{AuxMapModFire}}","page":"API Reference","title":"SMGReader.firenucpos","text":"firenucpos(r::BamRecord, recorddata::StencillingData{AuxMapModFire})\n\nReturn fiber tools annotated nucleosome positions on read coordinates 0-based coordinates.\n\n\n\n\n\n","category":"method"},{"location":"api/#SMGReader.getmmml-Tuple{BamRecord}","page":"API Reference","title":"SMGReader.getmmml","text":"getmmml(record::BamRecord)\n\nFunction to retrieve location of MM and ML auxillary fields as AuxFields\n\n\n\n\n\n","category":"method"},{"location":"api/#SMGReader.getmodbasestrand-Tuple{UInt8, Bool}","page":"API Reference","title":"SMGReader.getmodbasestrand","text":"getmodbasestrand(b::UInt8, ispos::Bool) -> UInt8\n\nGiven a base character and strand, return the encoded base for modification search.\n\n\n\n\n\n","category":"method"},{"location":"api/#SMGReader.parse_mod_code-Tuple{Any, Any}","page":"API Reference","title":"SMGReader.parse_mod_code","text":"parse_mod_code(data, i)\n\nParse the modcode at position i in bytearray data Return (mod, next_i) where mod is a Modifcation and next_i is the next index after the modcode in the bytearray.\n\n\n\n\n\n","category":"method"},{"location":"api/#SMGReader.readtogenome!-Union{Tuple{T}, Tuple{BamRecord, VectorBuffer{T}}} where T","page":"API Reference","title":"SMGReader.readtogenome!","text":"readtogenome!(record::BamRecord, alignmap::VectorBuffer{T}) where {T}\n\nIn place update of alignmap VectorBuffer with basepair level read to genome map. Uses CIGAR information in record\n\n\n\n\n\n","category":"method"},{"location":"api/#Base-Extensions","page":"API Reference","title":"Base Extensions","text":"","category":"section"},{"location":"api/#Base.close-Tuple{HTSFileReader}","page":"API Reference","title":"Base.close","text":"close(reader::HTSFileReader)\n\nClose open reader.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.getindex-Union{Tuple{T}, Tuple{VectorBuffer{T}, AbstractVector{Bool}}} where T","page":"API Reference","title":"Base.getindex","text":"Base.getindex(buff::VectorBuffer{T}, inds::AbstractVector{Bool})\n\nReturn a regular array of elements where inds is true. Logical indexing must match the logical length of the buffer.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.getindex-Union{Tuple{T}, Tuple{VectorBuffer{T}, Int64}} where T","page":"API Reference","title":"Base.getindex","text":"Base.getindex(buff::VectorBuffer{T}, i::Int)\n\nReturn the element at logical index i in the buffer.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.getindex-Union{Tuple{T}, Tuple{VectorBuffer{T}, UnitRange{Int64}}} where T","page":"API Reference","title":"Base.getindex","text":"Base.getindex(buff::VectorBuffer{T}, r::UnitRange{Int})\n\nReturn a slice of the buffer for the given range r.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.iterate-Tuple{AuxFieldIter}","page":"API Reference","title":"Base.iterate","text":"Base.iterate(iter::AuxFieldIter)\nBase.iterate(iter::AuxFieldIter, i)\n\nIterate over the auxiliary fields in a BAM record.  Returns a tuple (AuxField, next_index) for each field, or nothing when done.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.iterate-Tuple{ModIterator}","page":"API Reference","title":"Base.iterate","text":"Base.iterate(iter::ModIterator)\n\nIterate through modifications in order they are present in BAM record returning `ModInfo` for each.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.open-Tuple{Type{HTSFileReader}, Any}","page":"API Reference","title":"Base.open","text":"open(HTSFileReader, path; idx_path=indexfile(path), bamthreads=Threads.nthreads())\n\nUse ccall to hts_open the file at path.     - idx_path gives location of index and is mandatory     - bamthreads specifies number of threads used by htslib\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.read!-Tuple{HTSFileReader, BamRecord}","page":"API Reference","title":"Base.read!","text":"Base.read!(reader::HTSFileReader, record::BamRecord)\n\nRead next record in file order from reader and in place store result in record.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.read-Tuple{HTSFileReader}","page":"API Reference","title":"Base.read","text":"Base.read(reader::HTSFileReader)\n\nAllocating version of read! Read next record in file order from reader return a record, recommended to use read!.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.setindex!-Union{Tuple{T}, Tuple{VectorBuffer{T}, Any, Int64}} where T","page":"API Reference","title":"Base.setindex!","text":"Base.setindex!(buff::VectorBuffer{T}, val, i::Int)\n\nSet the element at logical index i to val.\n\n\n\n\n\n","category":"method"},{"location":"directrna/#Direct-RNA","page":"Direct RNA","title":"Direct RNA","text":"","category":"section"},{"location":"directrna/","page":"Direct RNA","title":"Direct RNA","text":"This documentation is a work in progress. However, the advice on the chromatin stencilling page is relevent here.","category":"page"},{"location":"directrna/","page":"Direct RNA","title":"Direct RNA","text":"However, the main differnce is that the processed read data should:","category":"page"},{"location":"directrna/","page":"Direct RNA","title":"Direct RNA","text":"DirectRNAA(AuxMapMod()) - for just processing modified bases\nDirectRNAAlignBlocks(AuxMapMod()) - for processing modified bases with spliced genomic alignments","category":"page"},{"location":"directrna/","page":"Direct RNA","title":"Direct RNA","text":"using SMGReader\nusing  DataStructures\nfile = \"chromsten.cram\"\nreader = open(HTSFileReader, file)\n\nmodcounts = counter(Modification)\n\nrecorddata = DirectRNAAlignBlocks(AuxMapMod())\n\nfor record in eachrecord(reader)\n    processread!(record, recorddata)\n    for mi in ModIterator(record, recorddata)\n        push!(modcounts, mi.mod)\n    end\nend\nclose(reader)\n\nmodcounts","category":"page"},{"location":"directrna/#Supported-Modifications","page":"Direct RNA","title":"Supported Modifications","text":"","category":"section"},{"location":"#SMGReader.jl","page":"SMGReader.jl","title":"SMGReader.jl","text":"","category":"section"},{"location":"","page":"SMGReader.jl","title":"SMGReader.jl","text":"This package is a wrapper around htslib C library for BAM/CRAM file reading focussed on single molecule genomics.","category":"page"},{"location":"","page":"SMGReader.jl","title":"SMGReader.jl","text":"This package has been designed for fast iteration over BAM/CRAM files containing modification calls. Primarily tested and used on those output by dorado from Oxford Nanopore.","category":"page"},{"location":"","page":"SMGReader.jl","title":"SMGReader.jl","text":"The package is built for two principle applications:","category":"page"},{"location":"","page":"SMGReader.jl","title":"SMGReader.jl","text":"Chromatin stencilling - 6mA induced at accessible base - also known as Fiber-seq. This package integrates our FIRE annotated BAM/CRAM files FIRE.\nDirect RNA-seq - detection of modification on RNA","category":"page"},{"location":"#Installation","page":"SMGReader.jl","title":"Installation","text":"","category":"section"},{"location":"","page":"SMGReader.jl","title":"SMGReader.jl","text":"To install:","category":"page"},{"location":"","page":"SMGReader.jl","title":"SMGReader.jl","text":"] # package mode\nadd https://github.com/exetergrdd/SMGReader.jl","category":"page"},{"location":"","page":"SMGReader.jl","title":"SMGReader.jl","text":"Note installation will include htslib binary included in https://github.com/JuliaBinaryWrappers/htslib_jll.jl. This may not be the most recent version of hts lib.","category":"page"},{"location":"#Basic-Usage","page":"SMGReader.jl","title":"Basic Usage","text":"","category":"section"},{"location":"","page":"SMGReader.jl","title":"SMGReader.jl","text":"To iterate over all records in file order:","category":"page"},{"location":"","page":"SMGReader.jl","title":"SMGReader.jl","text":"using SMGReader\n\nfile = \"chromsten.cram\"\nreader = open(HTSFileReader, file)\nfor record in eachrecord(reader)\n    ### do something\nend\nclose(reader)","category":"page"},{"location":"","page":"SMGReader.jl","title":"SMGReader.jl","text":"To iterate over record in a given region:","category":"page"},{"location":"","page":"SMGReader.jl","title":"SMGReader.jl","text":"using SMGReader\n\nchrom = \"chr1\"\nloc   = 1:10000 \n\nfile = \"chromsten.cram\"\nreader = open(HTSFileReader, file)\nfor record in eachintersection(reader, chrom, loc)\n    ### do something\nend\nclose(reader)","category":"page"},{"location":"","page":"SMGReader.jl","title":"SMGReader.jl","text":"Note that if interested in a large proportion of reads of a file it may be faster to iterate over entire file.","category":"page"},{"location":"#Contents","page":"SMGReader.jl","title":"Contents","text":"","category":"section"},{"location":"","page":"SMGReader.jl","title":"SMGReader.jl","text":"","category":"page"},{"location":"chromstencil/#Chromatin-Stencilling","page":"Chromatin Stencilling","title":"Chromatin Stencilling","text":"","category":"section"},{"location":"chromstencil/","page":"Chromatin Stencilling","title":"Chromatin Stencilling","text":"This library is designed for streaming through a file handling a single read at a time avoiding excessive memory allocation. While it is possible to collect multiple reads into memory, see example below, this should be discouraged currently. ","category":"page"},{"location":"chromstencil/#Iteration-of-modification","page":"Chromatin Stencilling","title":"Iteration of modification","text":"","category":"section"},{"location":"chromstencil/","page":"Chromatin Stencilling","title":"Chromatin Stencilling","text":"Below is an example of calculating the total number of modification calls, note this is a simple example for all other uses you will want to preallocate StencillingData to help manage memory used during iteration:","category":"page"},{"location":"chromstencil/","page":"Chromatin Stencilling","title":"Chromatin Stencilling","text":"using SMGReader\nusing  DataStructures\nfile = \"chromsten.cram\"\nreader = open(HTSFileReader, file)\n\nmodcounts = counter(Modification)\n\nfor record in eachrecord(reader)\n    for mi in ModIterator(record)\n        push!(modcounts, mi.mod)\n    end\nend\nclose(reader)\n\nmodcounts","category":"page"},{"location":"chromstencil/","page":"Chromatin Stencilling","title":"Chromatin Stencilling","text":"The ModIterator returns ModificationInfo which has the following fields","category":"page"},{"location":"chromstencil/","page":"Chromatin Stencilling","title":"Chromatin Stencilling","text":"    mi.mod::Modification  ### the modification\n    strand::Bool          ### the strand of the modification\n    pos::Int              ### the position of the mod on the read in the direction of the read\n    prob::UInt8           ### mod probability [0,255], divide by 255 to get the probability.","category":"page"},{"location":"chromstencil/","page":"Chromatin Stencilling","title":"Chromatin Stencilling","text":"Supported modifications that mi.mod can take: Currently supported mod codes:","category":"page"},{"location":"chromstencil/","page":"Chromatin Stencilling","title":"Chromatin Stencilling","text":"Enum value Modification BAM code\nmod_6mA N6-methyladenine a\nmod_5mC 5-methylcytosine m\nmod_5hmC 5-hydroxymethylcytosine h\nmod_inosine Inosine 17596\nmod_pseU Pseudouridine 17802\nmod_4mC N4-methylcytosine 21839","category":"page"},{"location":"chromstencil/#Mapping-Read-Coordinates-to-the-Genome","page":"Chromatin Stencilling","title":"Mapping Read Coordinates to the Genome","text":"","category":"section"},{"location":"chromstencil/","page":"Chromatin Stencilling","title":"Chromatin Stencilling","text":"In BAM format the modifications are stored with respect to the strand of the read, we need to map these to the genome using the alignment information of the read. Below is an example for making a 6mA coverage track over a genomic interval. For this we need to preallocate a StencillingData type, this allocates memory to store information on how the read maps to the genome and index where the modification information is stored for each read:","category":"page"},{"location":"chromstencil/","page":"Chromatin Stencilling","title":"Chromatin Stencilling","text":"using SMGReader\nusing  DataStructures\nfile = \"chromsten.cram\"\nreader = open(HTSFileReader, file)\n\nchrom, loc = \"chr10\", 71027756:71163638 ### coordinates of the HK1 locus ## 1-based coords\nmodthresh = 0.9 ## anything with mod prob > 0.9 will be counted a modified\nn = length(loc)\nmodcounts = zeros(n)\nbasecounts = zeros(n)\n\n### Preallocate memory to store information about the read\n### AuxMapMod() specifies the MM/ML fields in the auxillary read data\nrecorddata = StencillingData(AuxMapMod()) \n\nfor record in eachintersection(reader, chrom, loc)\n    processread!(record, recorddata)                 ## update reccorddata with new read \n    for mi in ModIterator(record, recorddata) \n        (mi.mod == mod_6mA) || continue              ## require that the mod is 6mA\n        genomepos = recorddata.alignmap[mi.pos]      ## 0-based coordinate\n        if !iszero(genomepos)                        ## if 0 position not in genome alignment\n            locpos = (genomepos + 1) - loc.start + 1 ## 1-based coords in interval\n            if mi.prob > 0.9*255                     ## check its modified\n                modcounts[locpos] += 1               ## total modified counts at position\n            end\n            basecounts[locpos] += 1                  ## total bases called at position\n        end\n    end\nend\nclose(reader)\n\nproportionmod = modcounts./basecount ### calculate the proportion modified","category":"page"},{"location":"chromstencil/#Access-to-FIRE-fields","page":"Chromatin Stencilling","title":"Access to FIRE fields","text":"","category":"section"},{"location":"chromstencil/","page":"Chromatin Stencilling","title":"Chromatin Stencilling","text":"There are a number of convenience functions to access FIRE fields. There are two key sets of fields:","category":"page"},{"location":"chromstencil/","page":"Chromatin Stencilling","title":"Chromatin Stencilling","text":"Nucleosomes: auxillary field ns and nl specify their position and length in read coordinates\nMethylation sensitive patches (MSPs): as, al, and aq specifies their position, length and quality\nMSP quality <  0.9*255 intepreted as a accessible linker region\nMSP quality >= 0.9*255 interpreted as FIRE element. ","category":"page"},{"location":"chromstencil/","page":"Chromatin Stencilling","title":"Chromatin Stencilling","text":"To access this information, the key difference is a different auxillary map is needed AuxMapModFire.","category":"page"},{"location":"chromstencil/","page":"Chromatin Stencilling","title":"Chromatin Stencilling","text":"...\nrecorddata = StencillingData(AuxMapModFire())\nfor record in eachrecord(reader)\n    processrecord!(record, reccorddata)\n    ## iterate over the nucleosomes in read coordinates\n    for (pos, len) in firenucs(record, recorddata)\n        ### do something \n    end\n    ## iterate over the MSPs in read coordinates\n    for (pos, len, qual) in firemsps(record, recorddata)\n        ### do something \n    end\nend\n...","category":"page"},{"location":"chromstencil/","page":"Chromatin Stencilling","title":"Chromatin Stencilling","text":"There are functions to access the fire positions, lengths, qualities etc. as vectors rather than iterating over them. Currently this is an internal API:","category":"page"},{"location":"chromstencil/","page":"Chromatin Stencilling","title":"Chromatin Stencilling","text":"nucpos  = SMGReader.firenucpos(record, recorddata) \nnuclen  = SMGReader.firenuclen(record, recorddata)\n\nmsppos  = SMGReader.firemsppos(record, recorddata)  \nmsplen  = SMGReader.firemsplen(record, recorddata)  \nmspqual = SMGReader.firemspqual(record, recorddata) ","category":"page"},{"location":"chromstencil/#Mapping-FIRE-fields-to-genome-coordinates","page":"Chromatin Stencilling","title":"Mapping FIRE fields to genome coordinates","text":"","category":"section"},{"location":"chromstencil/","page":"Chromatin Stencilling","title":"Chromatin Stencilling","text":"When mapping a FIRE field with a position and length to the genome, it is possible that either or both ends may be absent from the alignment. ","category":"page"},{"location":"chromstencil/","page":"Chromatin Stencilling","title":"Chromatin Stencilling","text":"This is currently down by constructing a convertor for a give record with firegenome. This API is a bit clunky and likely will be refined. However, it will skip over any fire field that maps incompletely to the genome. ","category":"page"},{"location":"chromstencil/","page":"Chromatin Stencilling","title":"Chromatin Stencilling","text":"...\nrecorddata = StencillingData(AuxMapModFire())\nfor record in eachrecord(reader)\n    processrecord!(record, reccorddata)\n    firegenomecoords = firegenome(record, recorddata)\n\n    ## iterate over the nucleosomes in genome coordinates\n    for (pos, len) in firegenomcoords(firenucs(record, recorddata))\n        ### do something \n    end\n    ## iterate over the MSPs in genome coordinates\n    for (pos, len, qual) in firegenomcoords(firemsps(record, recorddata))\n        ### do something with genome coordinates\n    end\nend\n...","category":"page"}]
}
